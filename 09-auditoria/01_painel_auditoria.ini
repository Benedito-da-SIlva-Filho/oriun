# 01_painel_auditoria.py
# ╔════════════════════════════════════════════════════════════════════╗
# ║     SCRIPTUM HONORIS — PAINEL DE AUDITORIA DE SINCRONISMO ORIUN  ║
# ║                                                                  ║
# ║  Este script analisa os logs de sincronismo e gera um painel     ║
# ║  por tabela, campo e tipo de evento, com base no dicionário.     ║
# ║  Também exporta o resumo em formato .txt para arquivamento.      ║
# ║                                                                  ║
# ║  “AUDITAR É HONRAR O QUE FOI FEITO, COM CLAREZA E VERDADE.”      ║
# ╚════════════════════════════════════════════════════════════════════╝

from collections import defaultdict
from Oriun.08_Dicionario.01_carregar_metadados_pg import carregar_metadados_pg
from sync_05_conexao_postgres import conectar_postgres

LOG_EXECUCAO = r"C:\Oriun\06-logs\execucao.log"
LOG_ERROS = r"C:\Oriun\06-logs\erros.log"
PAINEL_SAIDA = r"C:\Oriun\09-Auditoria\painel_resumo.txt"

def carregar_logs(caminho):
    try:
        with open(caminho, "r", encoding="utf-8") as f:
            return f.readlines()
    except Exception as e:
        print(f"Erro ao carregar log: {e}")
        return []

def extrair_evento_execucao(linha):
    if "[SYNC]" in linha and "Tabela" in linha and "campo" in linha:
        try:
            partes = linha.split("Tabela '")[1].split("' — campo '")
            tabela = partes[0]
            campo = partes[1].split("'")[0]
            return tabela, campo
        except:
            return None, None
    return None, None

def extrair_evento_erro(linha):
    if "Registro" in linha and "ausente" in linha and "tabela" in linha:
        try:
            return linha.split("tabela ")[-1].strip()
        except:
            return None
    return None

def gerar_painel(cursor_pg):
    log_execucao = carregar_logs(LOG_EXECUCAO)
    log_erros = carregar_logs(LOG_ERROS)

    painel = defaultdict(lambda: defaultdict(int))

    for linha in log_execucao:
        tabela, campo = extrair_evento_execucao(linha)
        if tabela and campo:
            painel[tabela]["sincronizados"] += 1
            painel[tabela][f"campo_{campo}"] += 1

    for linha in log_erros:
        tabela = extrair_evento_erro(linha)
        if tabela:
            painel[tabela]["erros"] += 1

    return painel

def imprimir_painel(painel, cursor_pg):
    for tabela in sorted(painel.keys()):
        try:
            metadado = carregar_metadados_pg(cursor_pg, tabela)
        except Exception as e:
            print(f"\n⚠ Tabela '{tabela}' não encontrada no dicionário: {e}")
            continue

        print(f"\n📁 Tabela: {tabela}")
        print("──────────────────────────────")
        print(f"✔ Registros sincronizados: {painel[tabela]['sincronizados']}")
        print(f"✖ Erros detectados: {painel[tabela].get('erros', 0)}")

        print("\n🧠 Campos alterados:")
        for campo in metadado["campos"]:
            key = f"campo_{campo}"
            if key in painel[tabela]:
                descricao = metadado["campos"][campo].get("descricao", "sem descrição")
                print(f"- {campo} ({descricao}): {painel[tabela][key]} alterações")

        print("\n📜 Campos sem descrição:")
        for campo, props in metadado["campos"].items():
            if not props.get("descricao"):
                print(f"- {campo}")

def exportar_painel_txt(painel, cursor_pg, caminho_saida):
    try:
        with open(caminho_saida, "w", encoding="utf-8") as f:
            for tabela in sorted(painel.keys()):
                try:
                    metadado = carregar_metadados_pg(cursor_pg, tabela)
                except Exception as e:
                    f.write(f"\n⚠ Tabela '{tabela}' não encontrada no dicionário: {e}\n")
                    continue

                f.write(f"\n📁 Tabela: {tabela}\